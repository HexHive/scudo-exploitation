import gdb
from scudocookie import calc_checksum


def forge_header(new_header, cookie, address):
    new_checksum = calc_checksum(address, cookie, new_header)
    forged_header = new_header + (new_checksum << 0x30)
    return forged_header


def read_uint(addr):
    result = gdb.execute(f'x/wx {hex(addr)}', to_string=True)
    data = int(result.split(":")[-1], 16)
    return data


def write_ulong(addr, data):
    gdb.execute(f'set {{long}}{hex(addr)}={hex(data)}')


def find_base_address(lib_name):
    result = gdb.execute(f"info proc mappings", to_string=True)
    for l in result.split("\n"):
        if lib_name in l:
            base = int(l.split("    ")[1],16)
            return base
    return None

def get_rip():
    result = gdb.execute(f'p/x $rip', to_string=True)
    print(result)
    return result.split("=")[-1]    

def get_var_value(var):
    result = gdb.execute(f'print {var}', to_string=True)
    print(result)
    return result.split("=")[-1].strip("\n").strip(" ")  

class ForgeChecksum(gdb.Command):

    def __init__(self):
        super(ForgeChecksum, self).__init__("forge", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        args = gdb.string_to_argv(arg)
        if len(args) > 0:
            if args[0].startswith("$"):
                # gdb variable, try resolving it's value
                chunk_addr = int(get_var_value(args[0]),16)
            else:
                chunk_addr = int(args[0],16)
            print(f"forging 0x8100 header for chunk at: {hex(chunk_addr)}!")
            libc_base = find_base_address("libc.so")
            cookie_addr = libc_base + 0xe0480
            cookie = read_uint(cookie_addr)
            print(f'cookie read from {hex(libc_base+0xe0480)}=>{hex(cookie)}')
            forged_header = forge_header(0x8100, cookie, chunk_addr)
            print(f'forged header: {hex(forged_header)}')
            write_ulong(chunk_addr-0x10, forged_header) 
        else:
            print("Usage: forge <chunk-address>")

ForgeChecksum()


def setup_stall_addr():
    stall_addr = find_base_address("libcodec2_hidl_client@1.1.so")+0x3fe0 #offset to unused area
    write_ulong(stall_addr, 0xfeeb)
    gdb.execute(f'x/i {hex(stall_addr)}')
    return stall_addr


class StallThread(gdb.Command):
    def __init__(self):
        super(StallThread, self).__init__("stall", gdb.COMMAND_USER)
        self.stored_rip_dict = {}
        self.stall_addr = None

    def invoke(self, arg, from_tty):
        args = gdb.string_to_argv(arg)
        return_thread = gdb.selected_thread().num 
        if len(args) > 0:
            if not self.stall_addr:
                self.stall_addr = setup_stall_addr()
            continue_cmd = False
            if len(args) == 2:
                if args[1] == "-c":
                    continue_cmd = True
            a0 = args[0]
            if a0 == "t":
                # stall current thread
                print("??")
                thread_id = gdb.selected_thread().num
                print(thread_id)
            elif a0 == "1":
                thread_id = 1
            else:
                print("usages: stall t/1 (stall either the current thread or thread 1)")
                return 
            if continue_cmd:
                if a0 == "t":
                    # logic here is that we want to unstall the one previously stalled thread, if arg is t then just the thread id that is not 1
                    thread_id = None
                    for t_id in self.stored_rip_dict:
                        if t_id != 1:
                            thread_id = t_id
                            break
                if thread_id not in self.stored_rip_dict:
                    print(f"ERROR, cannot continue thread that wasn't stalled: {self.stored_rip_dict}, {thread_id}")
                    return
                gdb.execute(f'thread {thread_id}')
                gdb.execute(f'set $rip={self.stored_rip_dict[thread_id]}')
                del self.stored_rip_dict[thread_id]
                gdb.execute(f'thread {return_thread}') #for convenience go back to original thread
            else:
                if len(self.stored_rip_dict) > 2:
                    print(f'cannot stall more threads!!')
                    return
                if thread_id in self.stored_rip_dict:
                    print(f'ERROR cannot stall already stalled thread {self.stored_rip_dict}, {thread_id}')
                    return
                gdb.execute(f'thread {thread_id}')
                rip = get_rip()
                print(rip)
                self.stored_rip_dict[thread_id] = rip
                gdb.execute(f'set $rip={hex(self.stall_addr)}')
                gdb.execute(f'thread {return_thread}') #for convenience go back to original thread
        else:
            print("usages: stall t/1 (stall either the current thread or thread 1, -c to continue)")

StallThread() 

class MemcpyB(gdb.Command):
    def __init__(self):
        super(MemcpyB, self).__init__("bmcp", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        thread_id = gdb.selected_thread().num
        gdb.execute(f'b *_ZNK7android6Parcel4readEPvm+356 thread {thread_id}')

MemcpyB()